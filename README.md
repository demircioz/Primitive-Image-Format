# ğŸ–¼ï¸ PIF - Primitive Image Format (SAÃ‰ 3.2)

A complete and elegant software suite for image compression and visualization, developed in **Java (Swing)**. This project uses the **Canonical Huffman** algorithm to offer an optimized proprietary storage format.

## ğŸ“– Table of Contents

* [Introduction](https://www.google.com/search?q=%23introduction)
* [Main Features](https://www.google.com/search?q=%23main-features)
* [MVC Architecture](https://www.google.com/search?q=%23mvc-architecture)
* [Project Structure](https://www.google.com/search?q=%23project-structure)
* [Compilation and Execution](https://www.google.com/search?q=%23compilation-and-execution)
* [Algorithm & Performance](https://www.google.com/search?q=%23algorithm--performance)
* [Authors](https://www.google.com/search?q=%23authors)
* [Acknowledgments](https://www.google.com/search?q=%23acknowledgments)

<a id="introduction"></a>

## ğŸª¶ Introduction

This project was created as part of **SAÃ‰ 3.2 (Semester 3)** at the IUT of Fontainebleau. Its goal is the design and implementation of a proprietary image file format named **PIF (Primitive Image Format)**, as well as the development of a software suite to manipulate it.

The PIF format relies on a lossless compression algorithm using **Canonical Huffman coding**. Unlike standard formats, it processes color components (Red, Green, Blue) independently to optimize the compression ratio while guaranteeing a perfect reconstruction of the original data.

To meet the project requirements, the application is divided into two complementary tools:

* **The Converter (Encoder):** Transforms standard images (PNG, JPG, BMP) into compressed `.pif` files after statistical pixel analysis.
* **The Viewer (Decoder):** Allows opening, decoding, and navigating (zoom and pan) within `.pif` format images.

The entire project adheres to a rigorous **MVC** architecture and was developed with a focus on ergonomics and portability (using a Makefile and JAR generation).

<a id="main-features"></a>

## ğŸš€ Main Features

### ğŸ› ï¸ Converter (Encoder)

* **ğŸ“Š Statistical Analysis**: Precise calculation of the frequency of each color intensity (0-255).
* **ğŸ” Technical Visualization**: Dynamic display of Huffman trees and generated canonical codes as interactive tables.
* **ğŸ”¨ Usability**: Uses *JMenuBar*, status bar, and full **Drag & Drop** support to load an image instantly.

### ğŸ–¼ï¸ Viewer (Decoder)

* **âš™ï¸ High-Fidelity Decoding**: Bit-by-bit reconstruction of the original image from the PIF archive.
* **âš“ Advanced Navigation**: Interactive rendering system allowing **Centered Zoom** (scroll wheel) and **Panning** (click & drag).
* **ğŸ˜€ Adaptability**: Automatic resizing of the interface based on the resolution of the loaded image.

<a id="mvc-architecture"></a>

## ğŸ—ï¸ MVC Architecture

The project follows a strict separation of concerns to ensure clean and maintainable code:

* **Model (`models/`)**: The algorithmic core. Handles Huffman tree construction, bit-packing, and binary stream manipulation.
* **View (`views/`)**: The visual interface. Uses Swing components with a focus on UX (system theme, Roboto/Segoe UI fonts).
* **Controller (`controllers/`)**: The conductors. Links user interactions to data processing and manages execution modes (GUI vs CLI).

<a id="project-structure"></a>

## ğŸ—‚ï¸ Project Structure

```bash
PIF_Project/
â”‚
â”œâ”€â”€ src/fr/iutfbleau/sae32_2025/
â”‚   â”œâ”€â”€ Main.java              # Main entry point (Launcher)
â”‚   â”œâ”€â”€ controllers/           # Stream managers (Converter, Decoder)
â”‚   â”œâ”€â”€ models/                # Compression logic (Huffman, Readers/Writers)
â”‚   â””â”€â”€ views/                 # Swing Interfaces (Frames, Panels, Theme)
â”‚
â”œâ”€â”€ res/                       # Visual resources (Icons, Background)
â”œâ”€â”€ diagrammes/                # UML Diagrams (PlantUML)
â”œâ”€â”€ build/                     # Compiled classes (generated by Make)
â”œâ”€â”€ doc/                       # Javadoc documentation (generated)
â”œâ”€â”€ Makefile                   # Complete project automation
â””â”€â”€ *.jar                      # Generated executable archives

```

<a id="compilation-and-execution"></a>

## âš™ï¸ Compilation and Execution

Project automation is managed by a `Makefile`. For Windows users who do not have this tool, we offer alternative commands via PowerShell or direct use of the executable archives.

### ğŸ§ For Linux / macOS (or Windows with Git Bash)

Use the `make` tool at the project root.

| Command | Action |
| --- | --- |
| `make` | Compiles the entire project into the `build/` folder. |
| `make run` | Launches the application via the welcome menu. |
| `make run-conv ARGS="in.jpg out.pif"` | Compresses an image directly via command line. |
| `make run-view ARGS="out.pif"` | Decodes and displays a PIF file immediately. |
| `make jar` | Generates the executable JAR files. |
| `make clean` | Removes compiled files and archives. |

### ğŸªŸ For Windows (Using JARs)

This is the fastest method using the existing **.jar** files.
If you need to regenerate the **.jar** files, here are the commands:

To generate **JAR** files on Windows without using the `Makefile`, you must use the `jar` tool provided with the JDK.

The goal here is to create "executable" archives (by specifying a `Main-Class` entry point) and include the resources so they are embedded inside the file.

Here are the steps to follow in your terminal (PowerShell or CMD):

---

#### 1. Preparation (Compilation)

Before creating the JAR, the `.class` files must be generated and the resources must be ready in the `build` folder.

```powershell
# Create the build folder and compile
mkdir build -Force
javac -d build -sourcepath src -encoding UTF-8 src/fr/iutfbleau/sae32_2025/Main.java

# Copy resources inside the build folder 
# (essential for AppTheme to find them in the JAR)
xcopy /E /I res\icons build\icons

```

---

#### 2. Creating Executable JARs

The `c` flag creates the archive, `v` displays details, `f` specifies the filename, and `e` defines the entry point (the class containing the `main`).

**A. The Main JAR (Launcher)**
This one launches the welcome menu with all options.

```powershell
jar cvfe PIF_App.jar fr.iutfbleau.sae32_2025.Main -C build .

```

**B. The Converter JAR (Standalone)**

```powershell
jar cvfe Converter.jar fr.iutfbleau.sae32_2025.controllers.Converter -C build .

```

**C. The Viewer JAR (Standalone)**

```powershell
jar cvfe Viewer.jar fr.iutfbleau.sae32_2025.controllers.Decoder -C build .

```

---

* **Launch the complete application:**
Double-click on `PIF_App.jar` or use:
```powershell
java -jar PIF_App.jar

```


* **Launch the Converter (Batch Mode):**
```powershell
java -jar Converter.jar image.jpg output.pif
# The arguments "image.jpg" & "output.pif" are optional

```


* **Launch the Viewer directly:**
```powershell
java -jar Viewer.jar output.pif
# The argument "output.pif" is optional

```



### ğŸªŸ For Windows (Manual Compilation and Execution)

If you do not have `make`, use these commands in your terminal (PowerShell or CMD).
This method uses the **Classpath** to include resources (images, icons) without having to move them.

* **Compile the project:**
```powershell
# Create the build folder if it doesn't exist
mkdir build

# Compile including the src folder
javac -d build -sourcepath src -encoding UTF-8 src/fr/iutfbleau/sae32_2025/Main.java

```


* **Launch the application (Main Menu):**
```powershell
java -cp "build;res" fr.iutfbleau.sae32_2025.Main

```


* **Launch the Converter:**
```powershell
java -cp "build;res" fr.iutfbleau.sae32_2025.controllers.Converter image.jpg output.pif
# The arguments "image.jpg" & "output.pif" are optional

```


* **Launch the Viewer:**
```powershell
java -cp "build;res" fr.iutfbleau.sae32_2025.controllers.Decoder output.pif
# The argument "output.pif" is optional

```



## ğŸ“ JavaDoc

### ğŸ§ On Linux / macOS (or via Makefile)

If you use the **Makefile** we prepared, this is the simplest method:

```bash
make doc

```

*This will create a `doc/` folder at the root containing the entire website for your documentation.*

---

### ğŸªŸ On Windows (PowerShell)

If you don't have `make`:

```powershell
# 1. Create the destination folder
mkdir doc 

# 2. Generate the Javadoc
# -d : destination folder
# -sourcepath : where the code is located
# -subpackages : packages to include
# -encoding : to handle accents correctly (UTF-8)
javadoc -d doc -sourcepath src -subpackages fr.iutfbleau.sae32_2025 -encoding UTF-8 -charset UTF-8

```

<a id="algorithm--performance"></a>

## ğŸ§® Algorithm & Performance

The project implements **Canonical Huffman**.

* **Advantage**: Instead of storing the complete tree in the file (which is very costly), we only store the code lengths.
* **Result**: The decoder mathematically reconstructs the exact tree, significantly optimizing compression gains.

<a id="authors"></a>

## ğŸ‘¨â€ğŸ’» Authors

| Name | Profile | Role |
| --- | --- | --- |
| **Canpolat DEMIRCIâ€“Ã–ZMEN** | [Git](https://grond.iut-fbleau.fr/demircio) | Decoder & UI/UX Design |
| **Maxime ELIOT** | [Git](https://grond.iut-fbleau.fr/eliot) | Flow Logic, Models & Encoder |
| **Luka PLOUVIER** | [Git](https://grond.iut-fbleau.fr/plouvier) | Encoder & Data Structure + Decoder |

*BUT2 Computer Science â€“ 2025/2026 â€“ IUT of Fontainebleau (UPEC)*

<a id="acknowledgments"></a>

## ğŸ™ Acknowledgments

* Thanks to Luc HERNANDEZ for his courses on byte streams and data structures.
* Thanks to Florent MADELAINE for his explanations on Huffman coding, its tree & how canonical code works.

---

> ### ğŸ Final Note: 17/20
